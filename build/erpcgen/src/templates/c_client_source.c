/*
 * AUTOMATICALLY GENERATED FILE - DO NOT EDIT
 */

// Generated from /home/patrick/erpc/server/ra_wifi_erpc_server/r_wifi_erpc_server/erpc/erpcgen/src/templates/c_client_source.template
extern const char * const kCClientSource;

const char * const kCClientSource = 
"{% set source = \"client\" >%}\n"
"{% if mlComment != \"\" %}\n"
"{$mlComment}\n"
"\n"
"{% endif %}\n"
"{$commonHeader()}\n"
"\n"
"#include \"{$clientCHeaderName}\"\n"
"#include \"{$clientCppHeaderName}\"\n"
"#include \"erpc_manually_constructed.hpp\"\n"
"{% set utils = false >%}\n"
"{% for iface in group.interfaces %}\n"
"{%  if (count(iface.callbacksAll) > 0) && (utils == false) %}\n"
"#include \"erpc_utils.hpp\"\n"
"{%   set utils = true >%}\n"
"{%  endif %}\n"
"{% endfor %}\n"
"\n"
"using namespace erpc;\n"
"using namespace std;\n"
"{$usingNamespace() >}\n"
"{% for iface in group.interfaces %}\n"
"{%  if count(iface.callbacksAll) > 0 %}\n"
"\n"
"{%   for cb in iface.callbacksAll %}\n"
"static const {$cb.name} _{$cb.name}[{$count(cb.callbacks)}] = { {%    for c in cb.callbacks %}{$c.name}{%     if !loop.last %}, {%     endif -- loop.last %}{%    endfor -- f.callbacks %} };\n"
"{%   endfor %}\n"
"{%  endif %}\n"
"{% endfor %}\n"
"\n"
"{% for iface in group.interfaces %}\n"
"#if ERPC_ALLOCATION_POLICY == ERPC_ALLOCATION_POLICY_DYNAMIC\n"
"{$iface.clientClassName} *s_{$iface.clientClassName} = nullptr;\n"
"#else\n"
"ERPC_MANUALLY_CONSTRUCTED_STATIC({$iface.clientClassName}, s_{$iface.clientClassName});\n"
"#endif\n"
"{% endfor -- iface %}\n"
"{% for iface in group.interfaces %}\n"
"{%  for fn in iface.functions %}\n"
"\n"
"{$fn.prototype}\n"
"{\n"
"{% if count(fn.callbackParameters) > 0 %}\n"
"    uint16_t _fnIndex;\n"
"{%  for cb in fn.callbackParameters%}\n"
"    {% if cb.interface != \"\"%}{$cb.interface}{% else %}{$iface.interfaceClassName}{% endif %}::{$cb.type} _{$cb.name} = NULL;\n"
"{%  endfor %}\n"
"{% endif%}\n"
"{% if fn.returnValue.type.isNotVoid %}\n"
"    {$fn.returnValue.resultVariable}{% if fn.returnValue.isNullReturnType %} = NULL{% endif %};\n"
"{% endif %}\n"
"{% if count(fn.callbackParameters) > 0 %}\n"
"{% for cb in fn.callbackParameters if cb.in %}\n"
"\n"
"    if (findIndexOfFunction((arrayOfFunctionPtr_t)_{$cb.type}, sizeof(_{$cb.type})/sizeof({$cb.type}), (functionPtr_t){$cb.name}, _fnIndex))\n"
"    {\n"
"        {% if cb.interface != \"\"%}{$cb.interface}{% else %}{$iface.interfaceClassName}{% endif %}::get_callbackAddress_{$cb.type}(_fnIndex, &_{$cb.name});\n"
"    }\n"
"{% endfor %}\n"
"\n"
"{%endif%}\n"
"    {% if fn.returnValue.type.isNotVoid %}result = {% endif %}s_{$iface.clientClassName}->{$fn.name}({% for param in fn.parameters %}{% if !loop.first %}, {% endif %}{$param.pureNameC}{% endfor %});\n"
"{% for cb in fn.callbackParameters if cb.out %}\n"
"\n"
"    if ({% if cb.interface != \"\"%}{$cb.interface}{% else %}{$iface.interfaceClassName}{% endif %}::get_callbackIdx_{$cb.type}(&_{$cb.name}, _fnIndex))\n"
"    {\n"
"        *{$cb.name}=_{$cb.type}[_fnIndex];\n"
"    }\n"
"{% endfor %}\n"
"{% if fn.returnValue.type.isNotVoid %}\n"
"\n"
"    return result;\n"
"{% endif %}\n"
"}\n"
"{%  endfor -- fn %}\n"
"{% endfor -- iface %}\n"
"{% for iface in group.interfaces %}\n"
"\n"
"void init{$iface.clientClassName}(erpc_client_t client)\n"
"{\n"
"#if ERPC_ALLOCATION_POLICY == ERPC_ALLOCATION_POLICY_DYNAMIC\n"
"    erpc_assert(s_{$iface.clientClassName} == nullptr);\n"
"    s_{$iface.clientClassName} = new {$iface.clientClassName}(reinterpret_cast<ClientManager *>(client));\n"
"#else\n"
"    erpc_assert(!s_{$iface.clientClassName}.isUsed());\n"
"    s_{$iface.clientClassName}.construct(reinterpret_cast<ClientManager *>(client));\n"
"#endif\n"
"}\n"
"\n"
"void deinit{$iface.clientClassName}(void)\n"
"{\n"
"#if ERPC_ALLOCATION_POLICY == ERPC_ALLOCATION_POLICY_DYNAMIC\n"
"    if (s_{$iface.clientClassName} != nullptr)\n"
"    {\n"
"        delete s_{$iface.clientClassName};\n"
"        s_{$iface.clientClassName} = nullptr;\n"
"    }\n"
"#else\n"
"    s_{$iface.clientClassName}.destroy();\n"
"#endif\n"
"}\n"
"{% endfor -- iface %}\n"
;

